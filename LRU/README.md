# LRU
`LRU( Least Recently Used)`最近最少使用算法：将最近**最少使用**（即最近一直没有被使用）的内容作为替换对象。

利用一个队列，元素从队首入队列，从队尾出队列。每当元素被命中（即查询/更新的元素已存在队列中时）则将该元素放到队首位置，当队列满且需要插入新元素时，将队尾元素出队列。LRU认为队列尾部的元素就是**最近最少使用**的元素。

## 优缺点

优点：简单；

缺点：

- **突然访问不常使用的**数据，可能使缓存中经常引用的数据被替换；如：偶发的批量操作-批量查询历史数据，由于是批量，大量不常会用到的历史数据（冷数据）把缓存中的热数据替换掉了，会导致后面的缓存命中率下降，拖慢了对正常数据的查询速度。
- 对于比缓存大小稍大的**循环**访问情形，命中率会非常低；如：缓存大小为3，有4个数据块：`1,2,3,4`；循环访问该数据块，即`1,2,3,4,1,2,3,4,1...`，会发现从`4`开始每一个数据都无法命中。
- **不同访问概率**下的表现不佳。如，数据集`{1,2}`和数据集`{a,b,c,d,e}`，访问按照两个数据集交替的方式：`1,a,2,b,1,c,2,d,1,e,2,a...`；假定缓存大小为3，可以发现，虽然`{1,2}`被访问的概率较高，但依然会被频繁地替换出去。

## 实现

参考：[Leetcode-LRU Cache](https://leetcode.cn/problems/lru-cache/); [Leetcode-LRU Cache LCCI](https://leetcode.cn/problems/lru-cache-lcci/); [Leetcode-LRU](https://leetcode.cn/problems/OrIXps/); 

为了提高查询的效率可以借助`map`，为了提高插入/删除的效率可以借助**链表**，将这两者结合起来进行实现。
