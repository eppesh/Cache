[toc]

说明：算法详细内容请参考原论文[1] ，本篇笔记仅作为自己学习的小总结，可能存在理解偏差或实现bug，仅供参考。

---

LIRS算法的理解与简易实现。

**摘要：**尽管LRU算法已经被广泛应用于缓存管理，但其并不能有效处理具有弱局部性特征的访问模式。一些基于LRU的改进算法要么太复杂，要么性能提升有限。基于当前这类算法的局限性，作者提出了LIRS算法。LIRS通过使用`Recency`来评估访问数据块的`Inter-Reference Recency(IRR)`，从而依据IRR值作出置换决策。相对的，LRU是直接通过`Recency`来预测下一次的访问时间。同时，LIRS也保留了LRU为预测未来数据块访问行为所作的假设。

Sean注（对可能存在不易理解的地方，会在下面加入一些个人理解的注解，下同）：

- `Recency`：下文统一称为**R值**；（下文会有详细解释，下同）

- `Inter-Reference Recency(IRR)`：下文统一称为**IRR值**；

- `Reference`: 在此处可理解为“**访问；被引用/提及**“；

- 数据块：即论文中的一个`Block`，下文统一称为**块**；此处，它是缓存中内容的基本单位；即，若说缓存大小为3，相当于缓存中可容纳3个数据块。

  > 后面算法实现部分，还可能会用`Entry`来表示数据块，跟`Block`其实是一个意思，这只是因为论文实现部分就是以`Entry`来称呼的。

- LRU所作假设：一个块如果最长时间没有被访问，那么等到它再次被访问也要等最长时间。

  >LRU makes a bold assumption -- a block that has not been accessed for the longest time would wait for the longest time to be accessed again.

- 访问局部性（Locality of reference）：指应用程序在访问内存的时候，**倾向于访问内存中较为靠近的值**[2]。又可分为两种：

  - 时间局部性：指程序在运行时，最近刚刚被引用过的一个内存位置容易再次被引用；比如，在调取一个函数的时候，前不久才调取过的本地参数容易再度被调取使用；
  - 空间局部性：指最近引用过的内存位置以及其周边的内存位置容易再次被使用。

  所谓弱局部性的访问模式，个人理解就是指那些不太符合局部性原理的访问模式，比如某些冷数据的突发访问或固定概率的访问等情形，这也正是LRU的缺陷所在，下文会有提到一些。

# LRU的缺陷

缓存置换算法是为了解决缓存空间有限情况下，尽可能避免**有价值的数据（即热点数据）**被淘汰/置换掉[3]。

`LRU( Least Recently Used)`最近最少使用算法：将内存中最近**最少使用**（即最近一直没有被使用）的内容作为替换对象。

那么，如何挑选最近最少使用的数据呢？最近最少使用的数据是根据时间局部性原理来预测的。基于此，该算法认为，在某个时刻被访问的数据，短时间内容易会被再次访问，其访问的概率是大于相对更久之前的访问数据。

LRU的**优点**：简单 + 适应性好；它只利用了非常有限的历史信息（即`Recency`,R值）进行预测；（只需要维护数据本身，不需要维护更多额外信息；像LFU还需要维护数据的访问频率信息）

LRU的**缺点**：

1. **突然访问不常使用的**数据，可能使缓存中经常引用的数据被替换；

   例如：偶发的批量操作-批量查询历史数据；由于是批量，大量不常会用到的历史数据（冷数据）把缓存中的热数据替换掉了，会导致后面的缓存命中率下降，拖慢了对正常数据的查询速度。

2. 对于比缓存大小稍大的**循环**访问情形，命中率会非常低；

   例如：缓存大小为3，现有4个数据块：`1,2,3,4`；循环访问该数据块，即`1,2,3,4,1,2,3,4,1...`，会发现从`4`开始每一个数据都无法命中。

   > 再如，当文件仅比内存大一点，且循环访问文件时。访问到文件末尾时，因为内存的限制，会淘汰掉马上将要访问的文件开头的数据。

3. **不同访问概率**下的表现不佳。

   例如，数据集`{1,2}`和数据集`{a,b,c,d,e}`，访问按照两个数据集交替的方式：`1,a,2,b,1,c,2,d,1,e,2,a...`；假定缓存大小为3，可以发现，虽然`{1,2}`被访问的概率较高，但依然会被频繁地替换出去。

   > 再如，数据库中有索引(key)和数据，一般地，索引访问的频率是远大于数据本身的。类似地，缓存访问key和value的频率也不一样，因此缓存持有key和value的时间也应该不一样。
   >
   > 因此，LIRS的栈中会存在非持久化的key（即下文的non-resident HIR块），就是代表着不同的持有时间。

关于LRU算法的实现，此处不再细述，详细可参考[LeetCode - LRU](https://leetcode.cn/problems/lru-cache). 

核心思路：维护一个栈结构来模拟缓存，数据块从栈顶插入，从栈底被淘汰。当缓存命中，则将命中的块移动到栈顶；当缓存满时，则将栈底块进行淘汰。

针对LRU算法的缺陷，很多大佬都做了针对性的改进，像LFU、2Q和LRU-K等，因为不是本文重点，暂不作进一步讨论。

# LIRS算法

Sean注：

这里先给出自己对LIRS算法的大致理解，下文是根据论文内容的较详细的说明，一些术语也可以下文找到更详细的介绍。

缓存置换算法主要就是在缓存满时找出哪个块需要被置换出去。

LRU根据R值（即`Recency`，最近被访问的时间）做决策，缓存满时将R值最大的置换出去。R值最大意味着是最近被访问的时间最长，也就是最近最久未被访问。

LRU算法实现时，**并不真正需要计算每个块的R值**，而是通过利用一个栈结构来模拟缓存。**要好好理解这个栈结构，后文很多设计都会用的这个思路。**

每次往缓存添加数据就通过栈顶来插入，每次需要淘汰数据就把栈底数据删除，每次缓存命中就把命中的数据重新移动/调整到栈顶。这样，越靠近栈顶的数据就越是新近被访问的数据（意味着R值越小），越靠近栈底的数据就越是最久未被访问的数据（意味着R值越大）；那么，从栈顶到栈底，R值便自然而然地从小到大排序开来，R值最大的数据也即是栈底数据，当缓存满时，不再需要比较找出R值最大的块，直接将栈底数据淘汰即可，这便是利用R值但又不需要真正计算R值就可以达到决策目的。LIRS也巧妙利用了这种设计技巧。

---

LIRS主要结合IRR值和R值做决策，缓存满时将IRR值较大同时其R值也较大的块置换出去。IRR值大意味着它最近两次访问之间的间隔大，（根据作者假设）意味着这次访问到下次访问之间的间隔还会比较大（即IRR值还会大），间隔大也就说明不经常被访问，可当作冷数据看待，那么IRR值大的块就是潜在被置换的对象。

> 论文中作者假定”如果一个块的IRR值大，那么该块的下一个IRR值也大“，基于这样的假设，就将IRR值较大的块进行置换，因为非常有可能这些块在再次访问之前就会被LRU淘汰掉。

LIRS的决策过程可这么理解：第一步：先按IRR值"排序"，把IRR值大的筛选出来；第二步，再从这些高IRR值的块中挑选出R值较大的，就是最终要淘汰的块。

第一步：”**按IRR值排序，把IRR值较大的块筛选出来**“；

为此，LIRS将数据块分为IRR值低的LIR块和IRR值高的HIR块（详细解释见下文，这里只需有个大致的概念即可），这样就按IRR值进行了区分，HIR块就都是IRR值大的块，便直接被第一轮筛选了出来。

第二步：”**从较高IRR值中挑选出R值较大的**“；

上面已经将较高IRR值的块筛选了出来，即HIR块，如何再从其中选出R值较大的块呢？回想LRU栈原理，假如也有这样一个栈，里面都是HIR块，新添加的块都是从栈顶插入，有命中则将其重新移至栈顶，这样栈顶块就是最近被访问过的（即R值较小的），栈底就是好久未被访问过的（即R值较大的），当缓存满需要置换时，栈底的块就是需要被淘汰的块。论文中的栈Q就是这样，相当于一个单独的LRU栈，后方还会介绍栈Q。

通过上面的介绍，我们会发现问题的关键是如何维护第一步中的LIR块集合和HIR块集合。为何要维护？因为数据块可能会因为访问频率的不同，致命其IRR值发生变化，从而会在LIR块和HIR块之间置换。LIRS也是通过使用一种栈结构来动态地维护LIR块集合和HIR块集合。

啰嗦这么多，只是为了脑海里有个对LIRS的整体印象，下面是详细说明。

## 整体概念

在理解LIRS算法之前，先了解R值与IRR值：

- `Recency`：R值；指**最近一次访问**到**当前时间**内访问其他非重复块的个数（这也即是LRU中维护的数据）；

- `Inter-Reference Recency(IRR)`：IRR值；最近连续访问同一个数据块之间访问其他不同数据块非重复个数。

  可通过下图[4]来帮助理解IRR值和R值:

  ![img](https://ask.qcloudimg.com/draft/1372436/g8q7or1lem.png?imageView2/2/w/1620)

  上图中，Cache1 的 IRR=3，连续两次访问 Cache1 之间访问的其他缓存块（即2，3，4，3）的非重复的个数（即3个），故中间缓存块1的IRR=3。同时，Cache1 的 R=2，上次访问的时间点（即图片**中间**访问1那个时间点）到当前时间点（即图片中访问最后一个5的时间点），这两个时间点之间，访问的其他缓存块（即5，6，5）的非重复的个数（即2个），故中间缓存块1的R=2；

  LIRS 与 LRU 最大的不同就是在淘汰 Cache 时候不仅考虑R值，同时会将IRR值纳入考量范围中。IRR用于记录块的历史信息，可以将其理解为访问频率。

---

### 常见概念

下面对常用到的几个概念进行说明：

- 缓存大小`L`：指缓存最大可容纳`L`个数据块；

- `Low Inter-reference Recency (LIR)`: IRR值小的数据块的集合；

  - LIR集合中的块都是IRR值比较小的，即**热数据**；
  - LIR集合的大小为：`Llirs = 99% * L`; （在缓存中占据99%的部分）

- `High Inter-reference Recency (HIR)`: IRR值大的数据块的集合；指HIR集合中的块都是IRR值比较大的，即**冷数据**；又分为：

  - `resident HIR`: 指常驻缓存的HIR块，表示这类HIR块存在于缓存中；这类块的大小为：`Lhirs = 1% * L`; (在缓存中占据1%的部分)
  - `non-resident HIR`: 指非常驻缓存的HIR块，表示这类HIR块不在缓存中。

- 栈S：用来动态维护LIR集合和HIR集合的栈结构（下面会细说）；

- 栈Q：用来方便搜索`resident HIR`块的栈结构，其大小为`Lhirs`；相当于所有常驻缓存的HIR块集合的一个副本（大小和内容一样，但排序顺序可能不同），如果缓存满需要淘汰一个HIR块时，Q栈底的块就是要淘汰的。

  > 可这样理解：缓存满需要淘汰时，需要：1. 决定哪个需要被淘汰；2. 找到缓存中需要被淘汰的块；3. 从缓存中删除该块；
  >
  > 栈Q的作用就相当于完成步骤1的作用，而缓存只需完成步骤2、3；
  >
  > 因为数据访问过程中，还可能会有LIR块转换成HIR块，因此将”决定哪个需要被淘汰“交给栈Q来完成更合适。

小结：

1. 缓存分为两部分：
   - LIR集合部分：大小为`Llirs`，占缓存总大小的99%；这样，保证了低IRR值的块，即LIR状态的块总是位于缓存中，在访问时这些块就总能命中。
   - resident HIR部分：大小为`Lhirs`，占缓存总大小的1%；
   - `L = Llirs + Lhirs`;
2. 每个访问的数据块都有一种状态：
   - LIR 状态：表示该块位于缓存中的LIR集合中；
   - resident HIR 状态：表示该块位于缓存中的 HIR集合部分；
   - non-resident HIR 状态：表示该HIR块不在缓存中；

<img src="https://raw.githubusercontent.com/eppesh/pic/main/20220914153311.png" style="zoom:67%;" />

Sean注：真正的结构要视具体实现而定，上图只是为了方便理解所做的粗略示意图。

### 演示例子

以论文中的Table 1为例来演示LIRS算法是如何选择待置换的数据块的，以及 LIR/HIR 状态是如何维护的。

![](https://raw.githubusercontent.com/eppesh/pic/main/20220914153720.png)

其中，“X”表示某一虚拟时刻访问了某个数据块。例如，数据块A分别在时刻1，6，8被访问。在时刻10，各数据块的IRR值和R值如上表所示。假定，`L = 3，Llirs = 2，Lhirs = 1`; `inf` 表示 infinite，即无穷大；

每个时刻各数据块的IRR值和R值如下图所示：

![](https://raw.githubusercontent.com/eppesh/pic/main/20220914153833.png)

由于`L=3，Llirs = 2，Lhirs = 1`，故时刻10，LIR 集合中是` {A, B}`（IRR值最小的位于LIR中，且大小不能超过`Llirs`），HIR 集合中是 `{C, D, E}`；由于`Lhirs=1`，且E是最近访问的，因此 resident HIR 只有`{E}`。如果访问 LIR集合中的数据块，LIR集合中的数据块依然保留在LIR中；如果访问 HIR 集合中的数据块，还需要确定是否应该将其调整至 LIR 集合中。

> Sean注：
>
> 上述例子中可发现以下小规律：（这些小规律有助于更好地理解下文）
>
> 1. 当某个块被再次访问时，其**IRR值就是它的**（前一时刻的）**R值**；例如t5的B，t6的A，t7的D和t8的A，图中有阴影的部分。说明，**IRR值是从R值得来的**。
> 2. 某一时刻，如果不是重复的块，R值都会更新，但IRR值不一定会更新；说明，R值的更新比IRR值的更新**快**，间接说明R值相对IRR值更”**新**“，即IRR值相比R值会有一些**outdated**；

假定 HIR 集合中新进入的数据块X的 IRR 值为`Xirr`，而 LIR 集合中 IRR 值最大的是 `Yirr`，如果 `Xirr < Yirr`，此时X不能再留在HIR中，Y也不能再留在LIR中，而是交换两者的位置；这就是动态维护 LIR和HIR集合。

> Sean注：resident HIR 集合和 LIR集合就好比是中学期间的普通班和特优班，当某次考试发现普通班（resident HIR集合）中有个同学X的综合成绩`Xirr`，比特优班中排名垫底同学Y的综合成绩`Yirr`还要好时（即`Xirr<Yirr`），就将同学X升至特优班，将同学Y降至普通班。每次考试（相当于每次数据访问）都会有综合成绩()`IRR`值)的更新，也就都可能会发生转换，这便是LIR和HIR集合的动态维护。

### 动态维护

LIRS算法成功的关键就在于能够**动态且灵敏地维护 LIR集合和HIR集合**。

当访问 HIR 集合中的数据块时，该数据块得到一个新的 IRR 值，该值等于该数据块的 R 值，此时，就需要判断该新 IRR 值是否比 LIR 集合中的IRR值小，以便决定是否需要将该数据块调整到 LIR 集合中。此时，有两种选择：1）将新IRR值跟LIR集合中的各个IRR值比较；2）将新IRR值跟LIR集合中的各R值比较。作者选择了第2种方式（即将新IRR值跟LIR集合中R值做比较），原因有2个：

1. IRR值在数据块的R值之前产生，可能会过时，这便跟 HIR集合中的新IRR值不相关；而一个数据块的R值不仅由自身的访问活动决定，也由最近其他数据块的访问活动决定。因此，将新IRR值跟LIR集合中的R值进行比较的结果可以将这个HIR中的数据块当作一个热点数据（即低IRR值的数据）。尽管我们说是使用IRR值来决定哪个数据块要被置换出去，但这里是新IRR值被直接用于比较中。

   > Sean注：不好理解，先记住这个结论就行，即”**新IRR值跟LIR集合中的R值比较就足够了**“。

2. 如果HIR集合中的新IRR值比LIR集合中某个数据块的R值还小，那么该新IRR值会比LIR集合中即将到来的IRR值还小。这是因为，LIR集合中数据块的R值是该数据块即将到来的IRR值的一部分，且不会大于即将到来的IRR值。

   > Sean注：
   >
   > 参考上面发现的小规律，IRR值等于其R值；可理解为：IRR_new < R_in_LIR = IRR_in_LIR，即新的IRR值只会比LIR中的IRR值小，所以只跟R值比较就够了。

一旦发现HIR集合中新的IRR值比LIR集合中所有数据块的最大R值还要小时，那么就将该HIR中的数据块和LIR集合中最大R值对应的数据块交换状态。

依据这条规则，我们就可以：

1. 让一个有着较小IRR值的HIR数据块进入LIR集合中，并替换掉一个LIR集合中的数据块；
2. 保持LIR集合的大小不超过`Llirs`，这样整个LIR集合就可以保持常驻在缓存中。

接着上面的例子，

- 如果时刻10访问是D，那么：

  ![](https://raw.githubusercontent.com/eppesh/pic/main/20220914162214.png)

  此时，LIR集合中有{A,B}，HIR集合中有{D}。由于D的IRR=2，比LIR集合中的B的R值（=3）要小；R(B)=3暗示了即将到来的IRR(B)>=3。因此，D的状态从HIR变为LIR，而B的状态从LIR变为HIR。更新后，LIR集合中有{A,D}，HIR集合中有{B}。

- 如果时刻10访问的是C：

  ![](https://raw.githubusercontent.com/eppesh/pic/main/20220914162352.png)

  那么，由于C的IRR=4，比LIR中最大的R值（=3）还要大，因此**不会发生状态调整**。此时，LIR集合中有{A,B}，HIR集合中有{C}。

## 基于LRU栈的LIRS算法

还记得LRU算法是如何利用栈结构巧妙地”避开直接计算R值但依旧利用R值找到待淘汰的数据“的吗？LIRS算法也可以借助LRU栈模型进行高效地构建。

回顾下LRU栈结构：它的容量大小为`L`，即包含`L`个`Entry`（每个Entry 就代表一个数据块Block），L是以数据块（Blocks）为单位计算的。这个栈很重要的一个特点是，每当栈中的数据块被访问时，就将该数据块放到栈顶，需要淘汰时则把栈底的数据块进行淘汰。也即最近访问的数据块永远位于栈顶，而栈底的数据块被认为是最近最久未被使用的。

> Sean注：
>
> 总结LRU栈的几个特点，下文的栈S和栈Q也都会用到：
>
> 1. 从栈顶插入数据；
> 2. 从栈底淘汰数据；（发生在需要淘汰数据时，例如栈满或动态维护LIR和HIR集合时）
> 3. 栈中数据块被命中会将其移至栈顶。
> 4. 从栈顶到栈底，栈中数据块的R值从小到大；

LIRS也是利用栈结构来记录R值，并动态维护LIR集合和HIR集合。不过，不同于LRU栈中只有常驻缓存的数据块才会被LRU算法维护，LIRS会在一个被称为**栈S**的LIRS栈中存储LIR数据块和HIR数据块。在操作上，栈S跟LRU栈相似，但栈S的大小可变。这样，依靠这个栈S，我们便不必显式地记录IRR值和R值，以及搜索最大R值（以进行淘汰）。

栈S中每个`Entry`记录了一个数据块的状态（LIR, resident HIR 或 non-resident HIR），为了方便搜索resident HIR块，将所有的resident HIR块放入栈Q中（栈Q的大小为`Lhirs`）。

一旦需要一个新数据块时，LIRS算法就从栈Q的底部移出去一个 resident HIR 数据块进行淘汰。但需要注意的是，这个被淘汰的 resident HIR 数据块如果一开始就位于栈S中时， 它还是会待在栈S中，只不过其 resident 状态会变成 non-resident 状态。同时，通过移走LIR数据块底下的HIR数据块，可以保证栈S的底部一定是一个LIR数据块。

一旦访问LISR栈S中的一个HIR数据块（这意味着至少有一个LIR数据块，例如S栈底这个LIR数据块，其即将到来的IRR值会比这个被访问的HIR数据块的新IRR值要大），此时我们交换该HIR数据块和S栈底这个LIR数据块的 LIR/HIR 状态。然后，S栈底那个LIR数据块会从栈S中被移出，并作为一个HIR数据块从栈Q的顶部加入Q。由于栈Q的容量很小（`Lhirs`），因此新加入Q的HIR数据块也会很快从缓存中被淘汰掉。

### 栈剪枝

在LIRS置换过程中，有一个操作称为栈S上的”栈剪枝“，该操作会移除掉S栈底的HIR数据块直到栈底是LIR数据块为止。

栈剪枝有2个目的：

1. 我们要确保栈底的数据块永远是LIR数据块；
2. 当栈底的LIR数据块被移除后，（被移除的LIR数据块）上面的连续HIR数据块并没有机会把状态从HIR变为LIR，因为它们的R值比LIR集合中新的最大R值还大。

---

针对上文的几处释疑：

1. 如何理解”访问LISR栈S中的一个HIR数据块，这意味着至少有一个LIR数据块，例如S栈底这个LIR数据块，其即将到来的IRR值会比这个被访问的HIR数据块的新IRR值要大“？

   答：由于S栈底必定是LIR块，且它的R值是栈S中最大的；而即将到来的IRR值等于其R值，因此，其即将到来的IRR值也会比这个被访问的HIR块的新IRR值大。

2. 为何LIRS不用计算/记录具体的IRR值和R值？

   答：LIRS算法使用了IRR值，该值越大表示被访问的频率越低，说明是个冷数据，就很可能被淘汰掉。我们已经知道，算法会选那些IRR值高同时R值还大的数据进行淘汰，而在缓存中通过将数据块分为LIR集合部分和resident HIR集合部分，已经按IRR值进行了初步筛选，即只需再从resident HIR集合部分中选出R值较大的。

   栈Q就是维护resident HIR集合中的数据，且根据前面对LRU栈的理解，知道栈底数据R值最大，因此栈Q的栈底数据就是被选中待淘汰的数据块。

   总的来说，虽然论文提出了IRR值的概念，但发现IRR值约等同于R值，因此IRR值的比较就转换为R值的比较。此外，栈S和栈Q的维护都是按照从栈顶到栈底R值从小到大排序的，因此任何需要比较的地方，直接取栈底数据块即可。通过栈结构，将原来需要计算数据并比较的过程，通过维护一个按R值从小到大排序的序列就解决了。

---

### 访问流程

数据块的访问流程。

当缓存未满时，新访问的数据块先进入LIR集合部分，这些块的状态就是LIR状态；LIR集合满了后，之后**第一次访问的任何数据块**都被设置为HIR状态，以及那些很长时间都没被访问的数据块也被设置为HIR状态，因为其当前不在栈S中。

> Sean注：
>
> 1. ”之后第一次访问的任何数据块都被设置为HIR状态“，这句好理解。当LIR集合满了后，新访问的数据块如果不在LIR集合中，则都属于HIR；如果此时`Lhirs`还未满，则其属于resident HIR状态；如果此时`Lhirs`也满了，且缓存中未命中，那么也要设置为resident HIR状态（它其实是non-resident HIR状态，因为缓存中不存在它嘛，但它是当前正在访问的，因此会重新进入缓存，只不过需要先把缓存清理出一个空位置来，它再进入缓存，也便是resident HIR状态了）。
> 2. ”以及那些很长时间都没被访问的数据块也被设置为HIR状态，因为其当前不在栈S中“，是指一些数据块，虽然不是第一次访问，但由于太久没有被再次访问，以致于不仅缓存中没有，连栈S中也没留它的历史信息了。这些块也被设置为resident HIR。跟这类块相对应的是那些虽不在缓存中，但依旧存在于栈S中的non-resident HIR块。

当缓存已满时，访问数据主要有3种情况：

1. 访问一个LIR块X，命中：

   - 将X移至S栈顶；
   - 如果X之前位于S栈底，则S栈剪枝；

2. 访问一个resident HIR块X，命中：

   - 将X移至S栈顶；

   - 根据移动前X的位置是否位于栈S中，再分2种情况：

     2.1 X位于栈S中：

     - 将X状态从resident HIR变为LIR；
     - 从栈Q中移除X；
     - S栈底的LIR块移动到Q栈顶，并将其状态从LIR变为resident HIR；
     - S栈剪枝；

     2.2 X不在S中：

     - 保持X的resident HIR状态不变；
     - 在栈Q中将X移至栈顶；

3. 访问一个non-resident HIR块X，未命中：

   - 将Q栈底数据块移出（此时，其状态就变为non-resident HIR），并把该块从缓存中移出；

   - 将X放入S栈顶；

   - 根据移动前X的位置是否位于栈S中，再分2种情况：

     3.1 X位于栈S中：

     - 将X状态从resident HIR变为LIR；
     - S栈底的LIR块移动到Q栈顶，并将其状态从LIR变为resident HIR；
     - S栈剪枝；

     3.2 X不在S中：

     - 保持X的resident HIR状态不变；
     - 将X放入Q栈顶；

---

结合上述流程，论文Table 1例子中各时刻栈S和栈Q的状态如下：

![](https://raw.githubusercontent.com/eppesh/pic/main/20220914183655.png)

注意：上图中，缓存中内容无顺序之分，但栈S和栈Q中有顺序之分。

### 存在的问题

LIRS算法存在的问题:

1. 对于顺序访问的块，可能会出现大量第一次访问的块；由于栈S没有大小限制，因此会在栈S中一直添加这些块，从而使栈S变得很大。优化的方法就是为栈S的大小设置一个阈值，当栈S的大小超过这个阈值时就去删除栈S中最接近栈底的HIR块。这个阈值大小可以是缓存大小的1.5倍~3倍，经测试不会造成太大的性能影响。
2. 栈剪枝操作的平均时间复杂度是`O(1)`，但并非是最坏时间复杂度是`O(1)`；

## 算法实现

按照论文中的流程，核心的算法逻辑已经很清晰，只需要选择合适的数据结构进行实现即可。

这里提供一种实现思路的伪代码，仅供参考。

```c++
if(cache中不存在)
{
    miss_count_++;
    if(LIR集合未满)
    {
        缓存中LIR集合插入该正在访问的数据块；
        更新栈S；
    }
    else if(Lhirs未满)
    {
        Lhirs中插入该正在访问的数据块；
        更新栈Q;
        更新栈S；
    }
    else // Llirs和Lhirs都满了,还不存在,说明访问的是一个non-resident HIR，需要置换
    {
        // 对应论文给出的步骤3的情形：访问一个 non-resident HIR 块 X；未命中；
        将Q栈底数据块移出（此时，其状态就变为non-resident HIR），并把该块从缓存中移出；
        将X放入S栈顶；
		根据移动前X的位置是否位于栈S中，再分2种情况：
		3.1 X位于栈S中：
			将X状态从resident HIR变为LIR；
			S栈底的LIR块移动到Q栈顶，并将其状态从LIR变为resident HIR；
			S栈剪枝；
		3.2 X不在S中：
			保持X的resident HIR状态不变；
			将X放入Q栈顶；
    }
}
else    // cache中已存在
{
    // 论文给出的步骤1,2的情形
    if(访问一个 LIR 块X；命中；)
    {
        将X移至S栈顶；
		如果X之前位于S栈底，则S栈剪枝；
    }
    else if(访问一个 resident HIR 块 X；命中)
    {
		将X移至S栈顶；
		根据移动前X的位置是否位于栈S中，再分2种情况：
		2.1 X位于栈S中：
			将X状态从resident HIR变为LIR；
			从栈Q中移除X；
			S栈底的LIR块移动到Q栈顶，并将其状态从LIR变为resident HIR；
			S栈剪枝；
		2.2 X不在S中：
			保持X的resident HIR状态不变；
			在栈Q中将X移至栈顶； 
    }
}
```

## 测试

源码中有3种测试，分别是模拟论文中Table1中的例子，单个缓存大小的测试和多个缓存大小的测试。

部分结果如下图所示：

<img src="https://raw.githubusercontent.com/eppesh/pic/main/20220917225833.png" style="zoom:67%;" />

![](https://raw.githubusercontent.com/eppesh/pic/main/20220917225624.png)

# 参考资料

[1] Making LRU Friendly to Weak Locality Workloads: A Novel Replacement Algorithm to Improve Buffer Cache Performance. --Song Jiang and Xiaodong Zhang;

[2] [Wiki-Locality of reference](https://en.wikipedia.org/wiki/Locality_of_reference) 和 [Wiki-访问局部性](https://zh.wikipedia.org/wiki/%E8%AE%BF%E9%97%AE%E5%B1%80%E9%83%A8%E6%80%A7); 

[3] [LRU不行，那就LIRS](https://juejin.cn/post/6943893480183693325); 

[4] [缓存淘汰算法LIRS原理与实现](https://cloud.tencent.com/developer/article/1464670); 

[5] [LRU-K，2Q，LIRS算法介绍与比较](https://blog.csdn.net/Pun_C/article/details/50920469);
